<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="OUTPUT_MATERIAL" loc="300, 300" />
		<node type="BSDF_DIFFUSE" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.0" loc="10, 300" />
		<node type="VALTORGB" interpolation="LINEAR" fac="0.5" stops="2" stop1="0.0|rgba(0.0, 0.0, 0.0, 1.0)" stop2="1.0|rgba(1.0, 1.0, 1.0, 1.0)" loc="-350, 286" />
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" dimensions="4" scale="1.50000" time="0.0" loc="-602, 269" />
	</nodes>
	<links>
		<link to="0" input="0" from="1" output="0" />
		<link to="1" input="0" from="2" output="0" />
		<link to="2" input="0" from="3" output="0" />
	</links>
	<scripts>
		<script name="MASimplexNoise.osl" id="0">
/*<br /> * MASimplexNoise.osl by Michel J. Anders (c)2013<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * license: public domain<br /> *<br /> * A speed-improved simplex noise algorithm for 2D, 3D and 4D in OSL.<br /> *<br /> * Based on example Java code by Stefan Gustavson (stegu@itn.liu.se).<br /> * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).<br /> * Better rank ordering method by Stefan Gustavson in 2012.<br /> *<br /> * This could be speeded up even further, but it's useful as it is.<br /> *<br /> * OSL port Michel Anders (varkenvarken) 2013-02-04<br /> * original comment is is left in place, OSL specific comments<br /> * are preceded by MJA<br /> *<br /> * This code was placed in the public domain by its original author,<br /> * Stefan Gustavson. You may use it as you see fit, but<br /> * attribution is appreciated.<br /> *<br /> */<br /><br />#include &quot;stdosl.h&quot;<br /><br />int fastfloor(float x) {<br /> int xi = (int)x;<br /> return x &lt; xi ? xi-1 : xi;<br />}<br /><br />// MJA it is safe to overload functions in OSL<br />// so here's some extra dot() versions<br />float dot(vector g, float x, float y) {<br /> return g[0]*x + g[1]*y; }<br /><br />float dot(vector g, float x, float y, float z) {<br /> return g[0]*x + g[1]*y + g[2]*z; }<br /><br />float dot(vector g, float t, float x, float y, float z, float w) {<br /> return g[0]*x + g[1]*y + g[2]*z + t*w; }<br /><br />shader MASimplexNoise(<br />    vector Vector = P,<br />    int Dimensions = 2, /* 2, 3 or 4 */<br />    float Scale = 1.0,<br />    float Time = 0.0,<br />    output float Fac = 0 )<br />{<br /> vector grad3[12] = {vector(1,1,0),vector(-1,1,0),<br />      vector(1,-1,0),vector(-1,-1,0),<br />      vector(1,0,1),vector(-1,0,1),<br />      vector(1,0,-1),vector(-1,0,-1),<br />      vector(0,1,1),vector(0,-1,1),<br />      vector(0,1,-1),vector(0,-1,-1)};<br /> // MJA I couldn't get OSL to compile an array of structs so<br /> // I separated a vec4 into a vector and a float<br /> vector grad4v[32]= {vector(0,1,1) ,vector(0,1,1)  ,<br />      vector(0,1,-1) ,vector(0,1,-1),<br />      vector(0,-1,1),vector(0,-1,1) ,<br />      vector(0,-1,-1),vector(0,-1,-1),<br />      vector(1,0,1) ,vector(1,0,1)  ,<br />      vector(1,0,-1) ,vector(1,0,-1),<br />      vector(-1,0,1),vector(-1,0,1) ,<br />      vector(-1,0,-1),vector(-1,0,-1),<br />      vector(1,1,0) ,vector(1,1,0)  ,<br />      vector(1,-1,0) ,vector(1,-1,0),<br />      vector(-1,1,0),vector(-1,1,0) ,<br />      vector(-1,-1,0),vector(-1,-1,0),<br />      vector(1,1,1) ,vector(1,1,-1) ,<br />      vector(1,-1,1) ,vector(1,-1,-1),<br />      vector(-1,1,1),vector(-1,1,-1),<br />      vector(-1,-1,1),vector(-1,-1,-1)};<br /> float grad4t[32]= { 1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,<br />      1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,<br />      0,0,0,0,0,0,0,0};<br /><br /> int perm[512] = {151,160,137,91,90,15,<br /> 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,<br /> 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,<br /> 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,<br /> 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,<br /> 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,<br /> 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,<br /> 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,<br /> 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,<br /> 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,<br /> 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,<br /> 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,<br /> 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,<br /> 151,160,137,91,90,15,<br /> 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,<br /> 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,<br /> 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,<br /> 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,<br /> 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,<br /> 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,<br /> 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,<br /> 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,<br /> 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,<br /> 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,<br /> 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,<br /> 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180};<br /> // MJA precomputing this table instead of calculating it as done in the<br /> // original code saves 30% running time.<br /> int permMod12[512] = { 7, 4, 5, 7, 6, 3, 11, 1, 9, 11, 0, 5, 2, 5, 7, 9, 8,<br /> 0, 7, 6, 9, 10, 8, 3, 1, 0, 9, 10, 11, 10, 6, 4, 7, 0, 6, 3, 0, 2, 5, 2, 10,<br /> 0, 3, 11, 9, 11, 11, 8, 9, 9, 9, 4, 9, 5, 8, 3, 6, 8, 5, 4, 3, 0, 8, 7, 2, 9,<br /> 11, 2, 7, 0, 3, 10, 5, 2, 2, 3, 11, 3, 1, 2, 0, 7, 1, 2, 4, 9, 8, 5, 7, 10,<br /> 5, 4, 4, 6, 11, 6, 5, 1, 3, 5, 1, 0, 8, 1, 5, 4, 0, 7, 4, 5, 6, 1, 8, 4, 3,<br /> 10, 8, 8, 3, 2, 8, 4, 1, 6, 5, 6, 3, 4, 4, 1, 10, 10, 4, 3, 5, 10, 2, 3, 10,<br /> 6, 3, 10, 1, 8, 3, 2, 11, 11, 11, 4, 10, 5, 2, 9, 4, 6, 7, 3, 2, 9, 11, 8, 8,<br /> 2, 8, 10, 7, 10, 5, 9, 5, 11, 11, 7, 4, 9, 9, 10, 3, 1, 7, 2, 0, 2, 7, 5, 8,<br /> 4, 10, 5, 4, 8, 2, 6, 1, 0, 11, 10, 2, 1, 10, 6, 0, 0, 11, 11, 6, 1, 9, 3, 1,<br /> 7, 9, 2, 11, 11, 1, 0, 10, 7, 1, 7, 10, 1, 4, 0, 0, 8, 7, 1, 2, 9, 7, 4, 6, 2,<br /> 6, 8, 1, 9, 6, 6, 7, 5, 0, 0, 3, 9, 8, 3, 6, 6, 11, 1, 0, 0, 7, 4, 5, 7, 6, 3,<br /> 11, 1, 9, 11, 0, 5, 2, 5, 7, 9, 8, 0, 7, 6, 9, 10, 8, 3, 1, 0, 9, 10, 11, 10,<br /> 6, 4, 7, 0, 6, 3, 0, 2, 5, 2, 10, 0, 3, 11, 9, 11, 11, 8, 9, 9, 9, 4, 9, 5, 8,<br /> 3, 6, 8, 5, 4, 3, 0, 8, 7, 2, 9, 11, 2, 7, 0, 3, 10, 5, 2, 2, 3, 11, 3, 1, 2,<br /> 0, 7, 1, 2, 4, 9, 8, 5, 7, 10, 5, 4, 4, 6, 11, 6, 5, 1, 3, 5, 1, 0, 8, 1, 5, 4,<br /> 0, 7, 4, 5, 6, 1, 8, 4, 3, 10, 8, 8, 3, 2, 8, 4, 1, 6, 5, 6, 3, 4, 4, 1, 10, 10,<br /> 4, 3, 5, 10, 2, 3, 10, 6, 3, 10, 1, 8, 3, 2, 11, 11, 11, 4, 10, 5, 2, 9, 4, 6, 7,<br /> 3, 2, 9, 11, 8, 8, 2, 8, 10, 7, 10, 5, 9, 5, 11, 11, 7, 4, 9, 9, 10, 3, 1, 7, 2,<br /> 0, 2, 7, 5, 8, 4, 10, 5, 4, 8, 2, 6, 1, 0, 11, 10, 2, 1, 10, 6, 0, 0, 11, 11, 6,<br /> 1, 9, 3, 1, 7, 9, 2, 11, 11, 1, 0, 10, 7, 1, 7, 10, 1, 4, 0, 0, 8, 7, 1, 2, 9, 7,<br /> 4, 6, 2, 6, 8, 1, 9, 6, 6, 7, 5, 0, 0, 3, 9, 8, 3, 6, 6, 11, 1, 0, 0};<br /><br /> // Skewing and unskewing factors for 2, 3, and 4 dimensions<br /> float F2 = 0.5*(sqrt(3.0)-1.0);<br /> float G2 = (3.0-sqrt(3.0))/6.0;<br /> float F3 = 1.0/3.0;<br /> float G3 = 1.0/6.0;<br /> float F4 = (sqrt(5.0)-1.0)/4.0;<br /> float G4 = (5.0-sqrt(5.0))/20.0;<br /><br /> if(Dimensions == 2){<br />   // 2D simplex noise<br />   float xin=Vector[0]*Scale, yin=Vector[1]*Scale;<br />   float n0, n1, n2; // Noise contributions from the three corners<br />   // Skew the input space to determine which simplex cell we're in<br />   float s = (xin+yin)*F2; // Hairy factor for 2D<br />   int i = fastfloor(xin+s);<br />   int j = fastfloor(yin+s);<br />   float t = (i+j)*G2;<br />   float X0 = i-t; // Unskew the cell origin back to (x,y) space<br />   float Y0 = j-t;<br />   float x0 = xin-X0; // The x,y distances from the cell origin<br />   float y0 = yin-Y0;<br />   // For the 2D case, the simplex shape is an equilateral triangle.<br />   // Determine which simplex we are in.<br />   int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords<br />   if(x0&gt;y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)-&gt;(1,0)-&gt;(1,1)<br />   else {i1=0; j1=1;}      // upper triangle, YX order: (0,0)-&gt;(0,1)-&gt;(1,1)<br />   // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and<br />   // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where<br />   // c = (3-sqrt(3))/6<br />   float x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords<br />   float y1 = y0 - j1 + G2;<br />   float x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords<br />   float y2 = y0 - 1.0 + 2.0 * G2;<br />   // Work out the hashed gradient indices of the three simplex corners<br />   int ii = i &amp; 255;<br />   int jj = j &amp; 255;<br />   int gi0 = permMod12[ii+perm[jj]];<br />   int gi1 = permMod12[ii+i1+perm[jj+j1]];<br />   int gi2 = permMod12[ii+1+perm[jj+1]];<br />   // Calculate the contribution from the three corners<br />   float t0 = 0.5 - x0*x0-y0*y0;<br />   if(t0 &lt; 0) n0 = 0.0;<br />   else {<br />   t0 *= t0;<br />   n0 = t0 * t0 * dot(grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient<br />   }<br />   float t1 = 0.5 - x1*x1-y1*y1;<br />   if(t1 &lt; 0) n1 = 0.0;<br />   else {<br />   t1 *= t1;<br />   n1 = t1 * t1 * dot(grad3[gi1], x1, y1);<br />   }<br />   float t2 = 0.5 - x2*x2-y2*y2;<br />   if(t2 &lt; 0) n2 = 0.0;<br />   else {<br />   t2 *= t2;<br />   n2 = t2 * t2 * dot(grad3[gi2], x2, y2);<br />   }<br />   // Add contributions from each corner to get the final noise value.<br />   // The result is scaled to return values in the interval [-1,1].<br />   Fac = 70.0 * (n0 + n1 + n2);<br /> } else if(Dimensions == 3){<br />  // 3D simplex noise<br />  float xin=Vector[0]*Scale, yin=Vector[1]*Scale, zin=Vector[2]*Scale;<br />  float n0, n1, n2, n3; // Noise contributions from the four corners<br />  // Skew the input space to determine which simplex cell we're in<br />  float s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D<br />  int i = fastfloor(xin+s);<br />  int j = fastfloor(yin+s);<br />  int k = fastfloor(zin+s);<br />  float t = (i+j+k)*G3;<br />  float X0 = i-t; // Unskew the cell origin back to (x,y,z) space<br />  float Y0 = j-t;<br />  float Z0 = k-t;<br />  float x0 = xin-X0; // The x,y,z distances from the cell origin<br />  float y0 = yin-Y0;<br />  float z0 = zin-Z0;<br />  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.<br />  // Determine which simplex we are in.<br />  int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords<br />  int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords<br />  if(x0&gt;=y0) {<br />  if(y0&gt;=z0)<br />   { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order<br />   else if(x0&gt;=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order<br />   else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order<br />  }<br />  else { // x0 &lt; y0<br />  if(y0 &lt; z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order<br />  else if(x0 &lt; z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order<br />  else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order<br />  }<br />  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),<br />  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and<br />  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where<br />  // c = 1/6.<br />  float x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords<br />  float y1 = y0 - j1 + G3;<br />  float z1 = z0 - k1 + G3;<br />  float x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords<br />  float y2 = y0 - j2 + 2.0*G3;<br />  float z2 = z0 - k2 + 2.0*G3;<br />  float x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords<br />  float y3 = y0 - 1.0 + 3.0*G3;<br />  float z3 = z0 - 1.0 + 3.0*G3;<br />  // Work out the hashed gradient indices of the four simplex corners<br />  int ii = i &amp; 255;<br />  int jj = j &amp; 255;<br />  int kk = k &amp; 255;<br />  int gi0 = permMod12[ii+perm[jj+perm[kk]]];<br />  int gi1 = permMod12[ii+i1+perm[jj+j1+perm[kk+k1]]];<br />  int gi2 = permMod12[ii+i2+perm[jj+j2+perm[kk+k2]]];<br />  int gi3 = permMod12[ii+1+perm[jj+1+perm[kk+1]]];<br />  // Calculate the contribution from the four corners<br />  float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;<br />  if(t0 &lt; 0) n0 = 0.0;<br />  else {<br />  t0 *= t0;<br />  n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);<br />  }<br />  float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;<br />  if(t1 &lt; 0) n1 = 0.0;<br />  else {<br />  t1 *= t1;<br />  n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);<br />  }<br />  float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;<br />  if(t2 &lt; 0) n2 = 0.0;<br />  else {<br />  t2 *= t2;<br />  n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);<br />  }<br />  float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;<br />  if(t3 &lt; 0) n3 = 0.0;<br />  else {<br />  t3 *= t3;<br />  n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);<br />  }<br />  // Add contributions from each corner to get the final noise value.<br />  // The result is scaled to stay just inside [-1,1]<br />  Fac = 32.0*(n0 + n1 + n2 + n3);<br /> } else if ( Dimensions == 4 ) {<br />  // 4D simplex noise, better simplex rank ordering method 2012-03-09<br />  float x=Vector[0]*Scale, y=Vector[1]*Scale, z=Vector[2]*Scale, w=Time*Scale;<br /><br />  float n0, n1, n2, n3, n4; // Noise contributions from the five corners<br />  // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in<br />  float s = (x + y + z + w) * F4; // Factor for 4D skewing<br />  int i = fastfloor(x + s);<br />  int j = fastfloor(y + s);<br />  int k = fastfloor(z + s);<br />  int l = fastfloor(w + s);<br />  float t = (i + j + k + l) * G4; // Factor for 4D unskewing<br />  float X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space<br />  float Y0 = j - t;<br />  float Z0 = k - t;<br />  float W0 = l - t;<br />  float x0 = x - X0;  // The x,y,z,w distances from the cell origin<br />  float y0 = y - Y0;<br />  float z0 = z - Z0;<br />  float w0 = w - W0;<br />  // For the 4D case, the simplex is a 4D shape I won't even try to describe.<br />  // To find out which of the 24 possible simplices we're in, we need to<br />  // determine the magnitude ordering of x0, y0, z0 and w0.<br />  // Six pair-wise comparisons are performed between each possible pair<br />  // of the four coordinates, and the results are used to rank the numbers.<br />  int rankx = 0;<br />  int ranky = 0;<br />  int rankz = 0;<br />  int rankw = 0;<br />  if(x0 &gt; y0) rankx++; else ranky++;<br />  if(x0 &gt; z0) rankx++; else rankz++;<br />  if(x0 &gt; w0) rankx++; else rankw++;<br />  if(y0 &gt; z0) ranky++; else rankz++;<br />  if(y0 &gt; w0) ranky++; else rankw++;<br />  if(z0 &gt; w0) rankz++; else rankw++;<br />  int i1, j1, k1, l1; // The integer offsets for the second simplex corner<br />  int i2, j2, k2, l2; // The integer offsets for the third simplex corner<br />  int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner<br />  // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.<br />  // Many values of c will never occur, since e.g. x&gt;y&gt;z&gt;w makes x &lt; z, y &lt; w and x &lt; w<br />  // impossible. Only the 24 indices which have non-zero entries make any sense.<br />  // We use a thresholding to set the coordinates in turn from the largest magnitude.<br />  // Rank 3 denotes the largest coordinate.<br />  i1 = rankx &gt;= 3 ? 1 : 0;<br />  j1 = ranky &gt;= 3 ? 1 : 0;<br />  k1 = rankz &gt;= 3 ? 1 : 0;<br />  l1 = rankw &gt;= 3 ? 1 : 0;<br />  // Rank 2 denotes the second largest coordinate.<br />  i2 = rankx &gt;= 2 ? 1 : 0;<br />  j2 = ranky &gt;= 2 ? 1 : 0;<br />  k2 = rankz &gt;= 2 ? 1 : 0;<br />  l2 = rankw &gt;= 2 ? 1 : 0;<br />  // Rank 1 denotes the second smallest coordinate.<br />  i3 = rankx &gt;= 1 ? 1 : 0;<br />  j3 = ranky &gt;= 1 ? 1 : 0;<br />  k3 = rankz &gt;= 1 ? 1 : 0;<br />  l3 = rankw &gt;= 1 ? 1 : 0;<br />  // The fifth corner has all coordinate offsets = 1, so no need to compute that.<br />  float x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords<br />  float y1 = y0 - j1 + G4;<br />  float z1 = z0 - k1 + G4;<br />  float w1 = w0 - l1 + G4;<br />  float x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords<br />  float y2 = y0 - j2 + 2.0*G4;<br />  float z2 = z0 - k2 + 2.0*G4;<br />  float w2 = w0 - l2 + 2.0*G4;<br />  float x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords<br />  float y3 = y0 - j3 + 3.0*G4;<br />  float z3 = z0 - k3 + 3.0*G4;<br />  float w3 = w0 - l3 + 3.0*G4;<br />  float x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords<br />  float y4 = y0 - 1.0 + 4.0*G4;<br />  float z4 = z0 - 1.0 + 4.0*G4;<br />  float w4 = w0 - 1.0 + 4.0*G4;<br />  // Work out the hashed gradient indices of the five simplex corners<br />  int ii = i &amp; 255;<br />  int jj = j &amp; 255;<br />  int kk = k &amp; 255;<br />  int ll = l &amp; 255;<br />  int gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;<br />  int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;<br />  int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;<br />  int gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;<br />  int gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;<br />  // Calculate the contribution from the five corners<br />  // MJA because I couldn't get OSL to compile an array of structs<br />  // the 4-vectors for the gradients are split into an array with<br />  // regular vectors (x,y,z) in grad4v and an array of floats<br />  // (for the w component) in grad4t<br />  float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;<br />  if(t0 &lt; 0) n0 = 0.0;<br />  else {<br />  t0 *= t0;<br />  n0 = t0 * t0 * dot(grad4v[gi0], grad4t[gi0], x0, y0, z0, w0);<br />  }<br />  float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;<br />  if(t1 &lt; 0) n1 = 0.0;<br />  else {<br />  t1 *= t1;<br />  n1 = t1 * t1 * dot(grad4v[gi1], grad4t[gi1], x1, y1, z1, w1);<br />  }<br />  float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;<br />  if(t2 &lt; 0) n2 = 0.0;<br />  else {<br />  t2 *= t2;<br />  n2 = t2 * t2 * dot(grad4v[gi2], grad4t[gi2], x2, y2, z2, w2);<br />  }<br />  float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;<br />  if(t3 &lt; 0) n3 = 0.0;<br />  else {<br />  t3 *= t3;<br />  n3 = t3 * t3 * dot(grad4v[gi3], grad4t[gi3], x3, y3, z3, w3);<br />  }<br />  float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;<br />  if(t4 &lt; 0) n4 = 0.0;<br />  else {<br />  t4 *= t4;<br />  n4 = t4 * t4 * dot(grad4v[gi4], grad4t[gi4], x4, y4, z4, w4);<br />  }<br />  // Sum up and scale the result to cover the range [-1,1]<br />  Fac = 27.0 * (n0 + n1 + n2 + n3 + n4);<br /> }<br />}<br /><br />
		</script>
	</scripts>
</material>