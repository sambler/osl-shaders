<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="TEX_COORD" dupli="False" loc="-466, 275" />
		<node type="SCRIPT" mode="INTERNAL" script="0" scale="5.0" vector="Vector(0.0, 0.0, 0.0)" time="0.0" loc="-265, 321" />
		<node type="BSDF_DIFFUSE" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.0" loc="-76, 318" />
		<node type="OUTPUT_MATERIAL" loc="115, 309" />
	</nodes>
	<links>
		<link to="3" input="0" from="2" output="0" />
		<link to="1" input="1" from="0" output="3" />
		<link to="2" input="0" from="1" output="1" />
	</links>
	<scripts>
		<script name="MA4D_voronoi.osl" id="0">
/*<br />    4d voronoi shader by Michel J. Anders (c)2012<br />    license: cc-by-sa<br />    http://blenderthings.blogspot.com.au/2012/12/a-4d-voronoi-osl-shader-for-blender.html<br />*/<br /><br />#include &quot;stdosl.h&quot;<br /><br />void cellnoise_color4d(float p[4], float c[4])<br />{<br />    c[0] = cellnoise(point(p[0],p[1],p[2]),p[3]);<br />    c[1] = cellnoise(point(p[1],p[0],p[2]),p[3]);<br />    c[2] = cellnoise(point(p[1],p[2],p[0]),p[3]);<br />    c[3] = cellnoise(point(p[3],p[1],p[2]),p[0]);<br />}<br /><br />/* Voronoi 4D . we always use distance squared as the distance metric */<br /><br />void voronoi4d(point p, float t, float da[4], point pa[4], float ta[4])<br />{<br />    /* returns distances in da, point coords in pa and time coords in ta*/<br />    int xx, yy, zz, tt, xi, yi, zi, ti;<br /><br />    float op[4] = {p[0],p[1],p[2],t};<br /><br />    xi = (int)floor(p[0]);<br />    yi = (int)floor(p[1]);<br />    zi = (int)floor(p[2]);<br />    ti = (int)floor(t);<br /><br />    da[0] = 1e10;<br />    da[1] = 1e10;<br />    da[2] = 1e10;<br />    da[3] = 1e10;<br /><br />    for (xx = xi - 1; xx &lt;= xi + 1; xx++) {<br />        for (yy = yi - 1; yy &lt;= yi + 1; yy++) {<br />            for (zz = zi - 1; zz &lt;= zi + 1; zz++) {<br />                for (tt = ti - 1; tt &lt;= ti + 1; tt++) {<br />                    float ip[4] = {xx, yy, zz, tt};<br />                    float vp[4];<br />                    cellnoise_color4d(ip,vp);<br />                    float pd[4] = { op[0] - (vp[0] + ip[0]),<br />                        op[1] - (vp[1] + ip[1]),<br />                        op[2] - (vp[2] + ip[2]),<br />                        op[3] - (vp[3] + ip[3])};<br />                    // always distance squared<br />                    float d = pd[0]*pd[0]+pd[1]*pd[1]+pd[2]*pd[2]+pd[3]*pd[3];<br /><br />                    vp[0] += xx;<br />                    vp[1] += yy;<br />                    vp[2] += zz;<br />                    vp[3] += tt;<br /><br />                    if (d &lt; da[0]) {<br />                        da[3] = da[2];<br />                        da[2] = da[1];<br />                        da[1] = da[0];<br />                        da[0] = d;<br /><br />                        pa[3] = pa[2]; ta[3] = ta[2];<br />                        pa[2] = pa[1]; ta[2] = ta[1];<br />                        pa[1] = pa[0]; ta[1] = ta[0];<br />                        pa[0] = point(vp[0],vp[1],vp[2]); ta[0] = vp[3];<br />                    }<br />                    else if (d &lt; da[1]) {<br />                        da[3] = da[2];<br />                        da[2] = da[1];<br />                        da[1] = d;<br /><br />                        pa[3] = pa[2]; ta[3] = ta[2];<br />                        pa[2] = pa[1]; ta[2] = ta[1];<br />                        pa[1] = point(vp[0],vp[1],vp[2]); ta[1] = vp[3];<br />                    }<br />                    else if (d &lt; da[2]) {<br />                        da[3] = da[2];<br />                        da[2] = d;<br /><br />                        pa[3] = pa[2]; ta[3] = ta[2];<br />                        pa[2] = point(vp[0],vp[1],vp[2]); ta[2] = vp[3];<br />                    }<br />                    else if (d &lt; da[3]) {<br />                        da[3] = d;<br />                        pa[3] = point(vp[0],vp[1],vp[2]); ta[3] = vp[3];<br />                    }<br />                }<br />            }<br />        }<br />    }<br />}<br /><br />shader node_voronoi_texture(<br />        float Scale = 5.0,<br />        point Vector = P,<br />        float Time = 0,<br />        output float Fac = 0.0,<br />        output color Color = color(0.0, 0.0, 0.0) )<br />{<br />    /* compute distance and point coordinate of 4 nearest neighbours */<br />    float da[4];<br />    point pa[4];<br />    float ta[4];<br /><br />    voronoi4d(Vector * Scale, Time * Scale, da, pa, ta);<br /><br />    Fac = fabs(da[0]); <br />    Color = color(Fac);<br />}<br /><br />
		</script>
	</scripts>
</material>