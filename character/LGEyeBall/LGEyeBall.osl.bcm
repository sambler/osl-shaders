<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="OUTPUT_MATERIAL" loc="288, 403" />
		<node type="SCRIPT" mode="INTERNAL" script="0" diffuseamt="1.05000" specularamt="0.07500" roughness="0.0" specularcolor="rgba(1.0, 1.0, 1.0, 1.0)" iriscolor="rgba(0.13528, 0.08432, 0.37241, 1.0)" irisoutercolor="rgba(0.40388, 0.34394, 0.68276, 1.0)" eyeballcolor="rgba(1.0, 1.0, 1.0, 1.0)" bloodcolor="rgba(0.80000, 0.05000, 0.05000, 1.0)" pupilcolor="rgba(0.0, 0.0, 0.0, 1.0)" pupilsize="0.19999" irissize="1.00000" bloodshotamt="0.59999" veinfreq="2.40000" veinlevel="3.09999" index="0.0" loc="15, 412" />
	</nodes>
	<links>
		<link to="0" input="0" from="1" output="0" />
	</links>
	<scripts>
		<script name="LGEyeBall.osl" id="0">
/*<br /> * LGEyeBall.osl by Shane Ambler<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * original script from -<br /> * http://www.renderman.org/RMR/RMRShaders.html<br /> *<br /> * previously -<br /> * eyeball.sl -- RenderMan compatible shader for an eyeball.<br /> *<br /> * DESCRIPTION:<br /> *   Makes a plastic-like surface which looks like an eyeball.  It's meant<br /> *   for use on a sphere.  The center of the pupil is at the &quot;north pole&quot;,<br /> *   i.e. where the t parameter is 1.  The colors of the pupil, iris, white<br /> *   part (eyeball), and blood vessels can be set individually.  Fractal<br /> *   functions are used for the veining and the iris mottling.<br /> * <br /> * PARAMETERS:<br /> *   DiffuseAmt, SpecularAmt, roughness, SpecularColor - work just like the plastic shader<br /> *   IrisColor - color of the iris<br /> *   EyeBallColor - color of the white part of the eyeball<br /> *   BloodColor - color of the blood vessels<br /> *   PupilColor - color of the pupil (opening)<br /> *   PupilSize - size of pupil (in &quot;t&quot; space)<br /> *   IrisSize - size of iris (in &quot;t&quot; space), must be larger than pupilsize<br /> *   BloodShotAmt - controls how BloodShotAmt the eye is (0=no blood, 1=very ugly)<br /> *   VeinFreq, VeinLevel - control the formation of the blood vessels<br /> *   Index - set between 0 and 1, lets you use this shader to generate<br /> *           non-identical eyeballs.<br /> *<br /> * ANTIALIASING: basic antialiasing of the boundaries between tissue types<br /> *               is performed.<br /> *<br /> * AUTHOR: written by Larry Gritz<br /> *<br /> * HISTORY:<br /> *      Nov 1991 - crude written of &quot;eye&quot; by lg for Herman's eyes for<br /> *                 &quot;Graphic Violence&quot;.  Original version hard coded in C.<br /> *      Dec 1993 - &quot;eye&quot; modified by lg to clean up a bit.<br /> *      10 Jan 1994 - recoded by lg in correct shading language.<br /> *      28 Jun 94 (lg) - revamped to add veins and iris mottling, renamed<br /> *                       &quot;eyeball&quot;<br /> *       7 Jan 95 (wave) - changed name to LGEyeBall for namespace reasons...<br /> *       8 Jan 95 (wave) - changed Ciris line to fix bug Larry figured out and changed defaults<br /> *       27 Feb 95 (wave) - changed PO line to fix bug Larry figured out to actually *use* index<br /> *<br /> * last modified  8 Jan 95 by Michael B. Johnson (wave)<br /> * 21/12/2012 converted to blender osl by Shane Ambler<br /> *<br /> */<br /><br />#include &quot;stdosl.h&quot;<br /><br />shader LGEyeBall (<br />        float DiffuseAmt = 0.9,<br />        float SpecularAmt = 0.8,<br />        float roughness = 0.1,<br />        color SpecularColor = color(1.0),<br />        color IrisColor = color (0.135289, 0.084323, 0.372417),<br />        color IrisOuterColor = color (0.403882, 0.343944, 0.68276),<br />        color EyeBallColor = color(1.0,1.0,1.0),<br />        color BloodColor = color(0.8,0.05,0.05),<br />        color PupilColor = color(0.0),<br />        float PupilSize = 0.2,<br />        float IrisSize = 1.0,<br />        float BloodShotAmt = 1.0,<br />        float VeinFreq = 8.0,<br />        float VeinLevel = 4.0,<br />        float Index = 0.0,<br />        output closure color BSDF = diffuse(N) )<br />{<br />#define snoise(P) (2*noise(P)-1)<br />#define MINFILTERWIDTH 1.0e-7<br />#define PUPILSIZE (PupilSize * .1)<br />#define IRISSIZE (IrisSize * .1)<br /><br />    color Ct;<br />    point Nf;<br />    point PP, PO;<br />    float i, turb, newturb, freq, f2;<br />    float displayed, newdisp;<br />    color Cball, Ciris;<br />    float irisstat, pupilstat;<br />    float bloody, tt;<br />    float ks, rough;<br />    float twidth, cutoff;<br /><br />    /* Calculate an appropriate filter width for antialiasing */<br />    twidth = max (abs(Dx(P[1])) + abs(Dy(P[1])), MINFILTERWIDTH);<br />    PO = transform (&quot;object&quot;, P) + Index;<br /><br />    /* Figure out where we are in the eyeball.  Use the following variables:<br />     * irisstat: 0 inside the iris/white boundary, 1 outside<br />     * pupilstat: 0 inside the pupil/iris boundary, 1 outside<br />     * bloody: how potentially bloody it is (fade as we get away from iris)<br />     */<br />    tt = 1-PO[1];<br />    irisstat = smoothstep (IRISSIZE, IRISSIZE+twidth, tt);<br />    pupilstat = smoothstep (PUPILSIZE, PUPILSIZE+twidth, tt);<br />    bloody = BloodShotAmt * (smoothstep (-IRISSIZE, 2.5*IRISSIZE, tt));<br /><br />    /* If we're somewhere in the white part and it's potentially bloody,<br />    * then calculate the veining pattern.  Otherwise, just use the color<br />    * of the whites.  The veining pattern is essentially summed zero sets<br />    * of turbulence functions.  Some stretching is done to get it to look<br />    * just right.<br />    */<br />    if (irisstat * bloody &gt; 0.001) {<br />        turb = bloody;<br />        freq = VeinFreq;<br />        displayed = 0;<br />        for (i = 1;  (i &lt;= VeinLevel) &amp;&amp; (turb &gt; 0.1);  i += 1) {<br />            newturb = 1 - abs (snoise(PO*freq + point(0,0,20*freq)));<br />            newdisp = pow (smoothstep (.85, 1, newturb), 10);<br />            displayed += (1-displayed) * newdisp * smoothstep (.1, .85, turb * turb);<br />            turb *= newturb;<br />            freq *= 2;<br />        }<br />        Cball = mix (EyeBallColor, BloodColor, smoothstep(0,.75,displayed));<br />    }<br />    else<br />        Cball = EyeBallColor;<br /><br />    Ciris = mix (IrisColor, IrisOuterColor, smoothstep (IRISSIZE*.8, IRISSIZE, tt));<br />    /* If we're somewhere in the iris, calculate the iris pattern, which is<br />     * just a stretched turbulence function.<br />     */<br />    if (irisstat &lt; 0.9999 &amp;&amp; pupilstat &gt; 0.0001) {<br />        turb = 0;<br />        freq = 1;<br />        f2 = 30;<br />        for (i = 1;  i &lt;= 4;  i += 1) {<br />            turb += snoise (PO*f2 + point(0,0,20*f2)) / freq;<br />            freq *= 2;<br />            f2 *= 2;<br />        }<br />        Ciris *= (1-clamp(turb/2,0,1));<br />    }<br /><br />    /* OK, now calculate a surface texture color (Ct) based on where we are<br />     * and what patterns we calculated.<br />     */<br />    Ct = mix (Ciris, Cball, irisstat);<br />    Ct = mix (PupilColor, Ct, pupilstat);<br /><br />    /* Make the eye a little glossier on the iris and pupil */<br />    ks = SpecularAmt * (1+2*(1-irisstat));<br />    rough = roughness * (1-0.75*(1-irisstat));<br /><br />    /* Now shade like plastic, but using our calculated surface color and<br />     * our modified values for roughness and SpecularAmt.<br />     */<br /><br />    Nf = normalize(N);<br />    BSDF = Ct * DiffuseAmt * diffuse(Nf);<br />    BSDF += SpecularColor * ks * ward(Nf,-normalize(I),rough,rough);<br />}<br /><br />
		</script>
	</scripts>
</material>